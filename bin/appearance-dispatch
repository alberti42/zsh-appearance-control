#!/bin/zsh -f

emulate -LR zsh -o warn_create_global -o no_short_loops
setopt extended_glob null_glob
umask 077

# External dispatcher for appearance changes.
#
# This script is intended to be called by OS watchers (WezTerm, launchd, etc.).
# It does not source the plugin and it runs with `-f` (no rc files).
#
# Behavior (tmux):
# - Set tmux option @dark_appearance to the provided value (0/1)
# - Signal shell panes (zsh) with USR1 so the plugin can sync on next hook

function _usage() {
  local _dispatch_script=$1
  print -r -- "usage: $_dispatch_script <tmux|cache> <on|off|1|0|true|false>" >&2
}

function _start_epoch_for_pid() {
  # Print process start time as epoch seconds.
  local pid=$1
  [[ $pid == <-> ]] || return 1

  local lstart start_epoch
  lstart=$(LC_ALL=C LANG=C command ps -p "$pid" -o lstart= 2>/dev/null) || return 1
  lstart=${lstart##[[:space:]]##}
  lstart=${lstart%%[[:space:]]##}
  [[ -n $lstart ]] || return 1

  case $OSTYPE in
    (darwin*) start_epoch=$(LC_ALL=C LANG=C command date -j -f "%a %b %e %T %Y" "$lstart" +%s 2>/dev/null) ;;
    (linux*)  start_epoch=$(LC_ALL=C LANG=C command date -d "$lstart" +%s 2>/dev/null) ;;
    (*)       return 1 ;;
  esac

  [[ $start_epoch == <-> ]] || return 1
  print -r -- "$start_epoch"
}

local type=${1:-}
local mode=${2:-}

if [[ -z $type || -z $mode ]]; then
  _usage "${0:t}"
  exit 1
fi

local dark_mode
case $mode in
  (1|on|true|enable|enabled)   dark_mode=1 ;;
  (0|off|false|disable|disabled) dark_mode=0 ;;
  (*)
    print -r -- "appearance-dispatch: invalid mode: $mode" >&2
    _usage "${0:t}"
    exit 1
  ;;
esac

case $type in
  (tmux)
    command -v tmux >/dev/null 2>&1 || {
      print -r -- "appearance-dispatch: tmux not found" >&2
      exit 1
    }

    command tmux set-option -gq @dark_appearance "$dark_mode" 2>/dev/null || true

    local pid comm
    command tmux list-panes -a -F '#{pane_pid}' 2>/dev/null |
      while IFS= read -r pid; do
        [[ $pid == <-> ]] || continue

        comm=$(command ps -p "$pid" -o comm= 2>/dev/null) || continue
        [[ $comm == *zsh ]] || continue

        command kill -USR1 "$pid" 2>/dev/null || true
      done
  ;;

  (cache)
    local cache_dir=${ZAC_CACHE_DIR:-${XDG_CACHE_HOME:-${HOME}/.cache}/zac}
    local pids_dir="$cache_dir/pids"
    local appearance_file="$cache_dir/appearance"

    command mkdir -p -- "$pids_dir" 2>/dev/null || {
      print -r -- "appearance-dispatch: failed to create: $pids_dir" >&2
      exit 1
    }
    command chmod 700 -- "$cache_dir" "$pids_dir" 2>/dev/null || true

    local tmp_file="$appearance_file.$$"
    builtin print -r -- "$dark_mode" >| "$tmp_file" 2>/dev/null || {
      print -r -- "appearance-dispatch: failed to write: $tmp_file" >&2
      exit 1
    }
    command mv -f -- "$tmp_file" "$appearance_file" 2>/dev/null || {
      command rm -f -- "$tmp_file" 2>/dev/null || true
      print -r -- "appearance-dispatch: failed to update: $appearance_file" >&2
      exit 1
    }
    command chmod 600 -- "$appearance_file" 2>/dev/null || true

    local pid_file pid stored_start cur_start comm
    for pid_file in "$pids_dir"/*; do
      pid=${pid_file:t}
      [[ $pid == <-> ]] || { command rm -f -- "$pid_file" 2>/dev/null || true; continue }

      IFS= read -r stored_start <"$pid_file" 2>/dev/null || stored_start=''
      stored_start=${stored_start%%[[:space:]]##}
      stored_start=${stored_start##[[:space:]]##}
      [[ $stored_start == <-> ]] || { command rm -f -- "$pid_file" 2>/dev/null || true; continue }

      cur_start=$(_start_epoch_for_pid "$pid") || cur_start=''
      if [[ -z $cur_start || $cur_start != $stored_start ]]; then
        command rm -f -- "$pid_file" 2>/dev/null || true
        continue
      fi

      comm=$(command ps -p "$pid" -o comm= 2>/dev/null) || comm=''
      [[ $comm == *zsh* ]] || continue

      command kill -USR1 "$pid" 2>/dev/null || {
        command rm -f -- "$pid_file" 2>/dev/null || true
      }
    done
  ;;

  (*)
    # TODO: define a convention for non-tmux propagation (cache file, etc.).
    print -r -- "appearance-dispatch: unsupported type: $type" >&2
    _usage "${0:t}"
    exit 1
  ;;
esac

exit 0
